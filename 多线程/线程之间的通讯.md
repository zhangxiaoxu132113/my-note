## 线程之间的通讯

#### 一，线程通讯的概念：

​	线程是操作系统中独立的个体，但是这些个体不进行特殊的处理就不能成为一个整体，线程之间的通讯就是成为整体的必用方式之一。当线程存在通讯指挥，系统间的交互性会更大，在提高CPU利用率的同时还会使用开发人员对线程任务的处理中进行有效的监督和把控。

#### 二，使用wait，notify实现线程之间的通讯

这两个方法都是Object的方法，也就是java为所有所有的对象都提供了这两个方法。

1. wait和notify必须结合synchronized来使用
2. wait是释放锁的，notify是不释放放锁的
3. 缺点，因为notify是不释放锁的，所以线程之间的通讯不具备时效性，必须等待调用notify的方法之后才能释放锁，唤起调用wait的线程。



#### 三，使用CountDownLatch来实现多线程的通讯的时效性

1. CountDownLatch介绍：（*引用网上的一篇对CountDownLatch的博文*）

   ​	Java的concurrent包里面的CountDownLatch其实可以把它看作一个计数器，只不过这个计数器的操作是原子操作，同时只能有一个线程去操作这个计数器，也就是同时只能有一个线程去减这个计数器里面的值。

   ​       你可以向CountDownLatch对象设置一个初始的数字作为计数值，任何调用这个对象上的await()方法都会阻塞，直到这个计数器的计数值被其他的线程减为0为止。

   ​       CountDownLatch的一个非常典型的应用场景是：有一个任务想要往下执行，但必须要等到其他的任务执行完毕后才可以继续往下执行。假如我们这个想要继续往下执行的任务调用一个CountDownLatch对象的await()方法，其他的任务执行完自己的任务后调用同一个CountDownLatch对象上的countDown()方法，这个调用await()方法的任务将一直阻塞等待，直到这个CountDownLatch对象的计数值减到0为止。