## 微信红包实现原理讨论
文章链接来自：https://www.jianshu.com/p/677287a002be
#### 一、背景
以下内容基于QCon某高可用架构群讨论总结
群里某同学问起微信红包架构，腾讯财付通同学作出解答，以下实现原理根据对话内容推导得出，不代表官方实现。
实现方式千百种，不追求方法复制，只追求推导过程的思考总结。最后转了新浪微博Tim总的另一种实现方式。

#### 二、微信红包实现原理
关键设计
- 通过cache抵挡大部分请求（是否能拆红包等）
- DB使用CAS操作更新红包计数记录
- DB、cache使用sharding，可水平扩展
#### 1. 新建红包
在DB、cache各新增一条记录
#### 2. 抢红包
请求访问cache，剩余红包个数大于0则可拆开红包
#### 3. 拆红包
请求访问cache，剩余红包个数大于0则继续，同时获取可抢红包数与金额
计算金额（从1分到剩余平均值2倍之间随机数，如果不是最后一个红包，剩余金额预留最少1分给cas更新失败，最后一位拿红包的人）
cas更新数据库（更新红包计数表记录【剩余红包个数、剩余红包金额】、插入领取记录）
更新失败，重复以上操作，直到更新成功或已领取完
更新成功，更新缓存
DB实现CAS操作伪代码（说明作用）：
```java
while (hadHongBao()) {
    //剩余红包个数
    def remainCount = getRemainCount()
    //实时计算获取红包金额
    def getAmount = calculateAmount()
    def result = sql.excute("update '红包计算表' set balance=${total-getAmount}, remainCount=${remainCount-1} where remainCount=${remainCount} and id=${id}")
    // 更新失败既继续执行循环，直到更新成功或已领取完，达到CAS效果
    if (result > 0) {
        // 更新成功，执行更新缓存等后续操作
        // ......
        break
    }
}
```
mrwater补充：一般更新成功之后，会在数据库插入一条数据，如果要对程序进行优化的话，可以在更新红包的时候，现在执行插入，这个的好处就是减少，行级锁的持续时间。
DB、cache主要数据结构
DB：红包计数表【主要字段：红包总金额、红包总个数、剩余红包个数、剩余红包金额】
cache：红包计数记录【主要字段：剩余红包个数、剩余红包金额】
其他补充
注：DB、cache使用sharding，访问量增大，DB、cache、服务端都可水平扩展。

#### 三、FAQ
上述内容讲解了抢红包关键实现原理，更多其他细节请看下述群记录摘要（以下内容转载自：https://www.zybuluo.com/yulin718/note/93148）

微信的金额什么时候算？
答：微信金额是拆的时候实时算出来，不是预先分配的，采用的是纯内存计算，不需要预算空间存储。。
采取实时计算金额的考虑：预算需要占存储，实时效率很高，预算才效率低。

实时性：为什么明明抢到红包，点开后发现没有？
答：2014年的红包一点开就知道金额，分两次操作，先抢到金额，然后再转账。
2015年的红包的拆和抢是分离的，需要点两次，因此会出现抢到红包了，但点开后告知红包已经被领完的状况。进入到第一个页面不代表抢到，只表示当时红包还有。

分配：红包里的金额怎么算？为什么出现各个红包金额相差很大？
答：随机，额度在0.01和剩余平均值2之间。
例如：发100块钱，总共10个红包，那么平均值是10块钱一个，那么发出来的红包的额度在0.01元～20元之间波动。
当前面3个红包总共被领了40块钱时，剩下60块钱，总共7个红包，那么这7个红包的额度在：0.01～（60/72）=17.14之间。
注意：这里的算法是每被抢一个后，剩下的会再次执行上面的这样的算法（Tim老师也觉得上述算法太复杂，不知基于什么样的考虑）。
这样算下去，会超过最开始的全部金额，因此到了最后面如果不够这么算，那么会采取如下算法：保证剩余用户能拿到最低1分钱即可。
如果前面的人手气不好，那么后面的余额越多，红包额度也就越多，因此实际概率一样的。

红包的设计
答：微信从财付通拉取金额数据郭莱，生成个数/红包类型/金额放到redis集群里，app端将红包ID的请求放入请求队列中，如果发现超过红包的个数，直接返回。
根据红包的裸祭处理成功得到令牌请求，则由财付通进行一致性调用，通过像比特币一样，两边保存交易记录，交易后交给第三方服务审计，如果交易过程中出现不一致就强制回归。

高并发处理：红包如何计算被抢完？
答：cache会抵抗无效请求，将无效的请求过滤掉，实际进入到后台的量不大。cache记录红包个数，原子操作进行个数递减，到0表示被抢光。财付通按照20万笔每秒入账准备，但实际还不到8万每秒。

通如何保持8w每秒的写入？
答：多主sharding，水平扩展机器。

据容量多少？
答：一个红包只占一条记录，有效期只有几天，因此不需要太多空间。

询红包分配，压力大不？
答：抢到红包的人数和红包都在一条cache记录上，没有太大的查询压力。

一个红包一个队列？
答：没有队列，一个红包一条数据，数据上有一个计数器字段。

有没有从数据上证明每个红包的概率是不是均等？
答：不是绝对均等，就是一个简单的拍脑袋算法。

拍脑袋算法，会不会出现两个最佳？
答：会出现金额一样的，但是手气最佳只有一个，先抢到的那个最佳。

每领一个红包就更新数据么？
答：每抢到一个红包，就cas更新剩余金额和红包个数。

红包如何入库入账？
数据库会累加已经领取的个数与金额，插入一条领取记录。入账则是后台异步操作。

入帐出错怎么办？比如红包个数没了，但余额还有？
答：最后会有一个take all操作。另外还有一个对账来保障。

四、另一种实现
群里讨论实现原理时，多人提出预分配金额的实现方式（新建红包时已分配好每一位抢到红包的金额），减少实时计算及CAS操作的性能损耗，财付通同学说到预分配金额还需要额外存储空间（更重要的可能是现在的实现方式已满足需求），后来新浪微博Tim总提出预分配方式不占用额外存储空间的方式，详细请看：
<a href="http://timyang.net/architecture/wechat-red-packet/">微信红包金额分配的算法</a>

实现原理
通过保存random seed达到预分配金额效果，既无需记录剩余红包金额，只需记录红包剩余数
抢红包时，针对红包剩余数进行DESC原子操作，当红包剩余数为0既抢完


### 补充点：什么是CAS数据库操作
#### 基于CAS机制的数据库update操作
由CAS的原理，可以考虑以类似的方式处理数据库的update操作。
假定订单 OD_0100 的总价款为1100 元， 现在要将其修改为 1500 元，
```sql
   update sale_order set order_amount = 1500.00
   where order_id = 'OD_0100'
```

采用 CAS 机制进行修改，假定已经知道订单修改前的总价款 1100，则update SQL为
```sql
   update sale_order set order_amount = 1500.00
   where order_id = 'OD_0100'
     and order_amount = 1100.00
```
若出现并发冲突，例如：order_amount 已经先其他请求修改为 900， 那么上面的 update 语句的操作结果数为 0； 此时，客户端需要重新查询订单，再尝试第二次修改。 这类似于 CAS 中的自旋。
