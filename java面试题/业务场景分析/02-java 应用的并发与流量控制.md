## 应用的并发与流量控制

前段时间在团队内部做了一次关于并发以及流量控制原理与实施的分享，今天花时间整理了下，分享给大家，同时也希望大家多提宝贵意见，共同进步。
说到java并发，不得不提一下java的线程模型


Java的线程模型
Java的并发实际上是在thread的基础上实现的，因此，说到并发限流的原理，不得不谈到java线程的五种状态之间的转换



图1 java线程的五种状态

![](http://dl.iteye.com/upload/attachment/0078/3488/daa633c8-d0dd-3ddf-a229-fb55c50497ec.png)

![](http://dl.iteye.com/upload/attachment/0078/3486/9961a496-5bc5-318b-b6b7-1b69cce13103.png)

从new状态到start，然后运行，running，当收到wait消息，或者sleep时，以及处理IO的时候，线程会进入Blocked状态，直到被notify，或者IO完成，当线程执行结束，会进入dead状态。

Java线程的实现实际上是跟操作系统的实现相关联的，不同的操作系统，有不同的线程模型，比如一对一模型，一对多模型，多对多模型，来完成用户态线程与内核态线程的对应。

![](http://dl.iteye.com/upload/attachment/0078/3502/99c145ae-8624-38d8-9f78-c45daff23e30.png)

一对一模型

![](http://dl.iteye.com/upload/attachment/0078/3500/cdf60cee-777e-3df4-81c7-8769db6ecb04.png)

多对一模型

![](http://dl.iteye.com/upload/attachment/0078/3494/321483d4-807c-3f04-bf35-725f9249bfa3.png)

多对多模型

当然，只有在running状态的线程，是占用cpu时间片的，而处于block状态的线程，会通过上下文切换，将线程状态信息存入内存的TCB(线程控制块)，这个过程中，会有一些寄存器的指令，程序计数器等等涉及线程运行状态的信息，保存到TCB中，操作系统会调度下一个运行状态的thread，将TCB状态还原，开始运行，等到时间片用完，又将线程切换出来。

上下文切换是纯粹调度的开销，可以讲是纯粹的时间浪费，但是这种浪费在所难免。

Samphore

先截取几段samphore实现的源代码，以代码说话更有说服力

![](http://dl.iteye.com/upload/attachment/0078/3492/f7e140bc-fa6d-3b0a-b5fe-7a5779b586e8.png)

很容易可以发现，samphore的实现是忙等待的，也就是说，在等待资源释放的过程中，samphore的acquire操作，不断的在做死循环，而这个操作，是需要占用和消耗cpu时间片的，这种机制也称作为spinlock(自旋锁)。

大家可能奇怪，为什么要不断做死循环呢，难道这样不是浪费资源么？

其实，任何事情都存在两面性，线程状态的切换过程中，可能会带来上下文切换的开销，如果在循环一段时间后，samphore便有线程将资源释放，samphore会很快解锁，相对于上下文切换的开销来说，这个开销会小的多，
也就是说，cpu时间片的浪费是值得的。但是，如果samphore所锁定的一段临界代码段，中间包含长时间的计算任务，亦或是磁盘，网络，DB等操作，
忙等的时间可能相当长，这样，spinlock的死循环就相当不划算了，这种可以预估到的长时间的等待，还不如使用上下文切换，将线程block住，让其真正的等待来的划算。

